                       Amber SSH
    GPU-Accelerated Particle Rendering System
                 Complete Technical Documentation
How Particles Transform Terminal Characters into Living, Shimmering Light
Table of Contents
  1.  Overview of the Particle System       3
  2.  Character to Particle Conversion      4
  3.  Particle Structure & Properties       6
  4.  The Shimmer Effect: Animation System  8
  5.  Force Field Physics                  11
  6.  GPU Rendering Pipeline               13
  7.  Shader Implementation                15
  8.  Performance Optimization             17
1. Overview of the Particle System
The Amber SSH particle system transforms traditional monospaced terminal characters into dynamic,
living clusters of glowing particles. Unlike conventional terminal rendering where each character is a
static bitmap or vector glyph, our system represents each character as a cloud of hundreds or
thousands of individual particles that pulse, shimmer, and respond to user interaction.
This creates an aesthetic reminiscent of nixie tube displays and vintage amber CRT terminals, while
leveraging modern GPU capabilities for real-time physics simulation and rendering at 120 FPS.
1.1 Core Principles
     <b>Principle</b>              <b>Description</b>
     Character Decomposition       Each character (A-Z, 0-9, symbols) is broken down into a 5×7 pixel bitmap
     Dense Particle Clouds         Each lit pixel becomes 5-50 particles (configurable density)
     Gaussian Distribution         Particles spread naturally around pixel centers using Gaussian randomness
     Multi-layered Rendering       4 particle layers with varying sizes create depth and glow
     Continuous Animation          Dual sine wave functions create organic pulse and flicker
     Physics Interaction           Mouse/touch creates force fields that push particles in real-time
1.2 Visual Pipeline Overview
The complete rendering pipeline transforms SSH terminal output into particle-rendered visuals
through several stages:
     SSH Data → ANSI Parser → Terminal Buffer (80×25) → Character Bitmaps → Particle
     Generation → Physics Update → GPU Upload → Shader Processing → Post-Effects →
     Display
2. Character to Particle Conversion
The transformation from terminal character to particle cloud is the heart of the system. This process
happens in real-time whenever the terminal screen updates.
2.1 Bitmap Font Representation
Each character is represented as a 5×7 boolean matrix. For example, the letter 'A':
    Character 'A' (5×7 bitmap): 0 1 1 1 0 ■ ■ ■ ■ ■ 1 0 0 0 1 → ■ ■ ■ ■ ■ 1 0 0 0 1 ■
    ■ ■ ■ ■ 1 1 1 1 1 ■ ■ ■ ■ ■ 1 0 0 0 1 ■ ■ ■ ■ ■ 1 0 0 0 1 ■ ■ ■ ■ ■ 1 0 0 0 1 ■
    ■ ■ ■ ■ Where 1 = lit pixel (will become particles) 0 = dark pixel (no particles)
2.2 Pixel to Particle Transformation
For each lit pixel in the bitmap, we generate N particles (where N = density setting, typically 20):
    For each lit pixel at position (col, row): 1. Calculate pixel center in screen
    coordinates: centerX = charX + col × pixelSize centerY = charY - row × pixelSize 2.
    For each particle (p = 0 to density): a. Generate random angle: θ = random(0, 2π) b.
    Generate Gaussian-distributed radius: radius = |gaussianRandom()| × pixelSize ×
    spread c. Calculate particle position: particleX = centerX + cos(θ) × radius
    particleY = centerY + sin(θ) × radius particleZ = random(-0.5, 0.5) × 0.5 // Depth
    variation d. Assign color from terminal cell color e. Initialize animation phases:
    pulse = random(0, 2π) flicker = random(0, 2π)
2.3 Gaussian Distribution Explained
The Gaussian (normal) distribution creates a natural clustering effect. Most particles appear near the
pixel center, with fewer particles farther away. This mimics the way phosphor glows on a CRT
display.
    Gaussian Random Function (Box-Muller Transform): u = random(0, 1) // Exclude 0 v =
    random(0, 1) // Exclude 0 gaussian = √(-2 × ln(u)) × cos(2π × v) This produces
    values centered around 0 with standard deviation ≈ 0.33. Taking the absolute value
    gives us only positive radial distances.
The spread parameter (0.1-0.8) controls how tightly particles cluster. Lower values create crisp,
focused characters. Higher values create a more diffuse, dreamy glow effect.
3. Particle Structure & Properties
3.1 Particle Data Structure
    struct Particle { QVector3D position; // (x, y, z) in screen coordinates QVector4D
    color; // (r, g, b, a) from terminal color float pulse; // Animation phase [0, 2π]
    float flicker; // Secondary animation phase [0, 2π] float radius; // Distance from
    pixel center QVector3D velocity; // Current velocity (for physics) };
3.2 Property Descriptions
   <b>Property</b>      <b>Purpose</b>                             <b>Range/Type</b>
   position.x           Horizontal screen position                 Float, screen pixels
   position.y           Vertical screen position                   Float, screen pixels
   position.z           Depth (creates layering)                   Float, -0.25 to +0.25
   color.rgb            Base color from terminal                   Float, 0.0 to 1.5 (HDR)
   color.a              Opacity/alpha                              Float, 0.0 to 1.0
   pulse                Primary wave phase                         Radians, 0 to 2π, wraps
   flicker              Secondary wave phase                       Radians, 0 to 2π, wraps
   radius               Original distance from center              Float, pixels
   velocity.xyz         Motion from force fields                   Vector3, pixels/frame
3.3 Multi-Layer Rendering
Particles are rendered in 4 layers with different sizes and opacities to create depth and glow:
   <b>Layer</b>    <b>Size</b> <b>Opacity</b> <b>Color Intensity</b>   <b>Purpose</b>
   0 (Core)        2.0px          1.0              120%                Brightest core, creates hotspot
   1 (Inner)       3.5px          0.8              100%                Main glow halo
   2 (Mid)         5.0px          0.5              80%                 Extended glow
   3 (Outer)       7.0px          0.3              60%                 Subtle outer aura
Each layer is rendered as a separate point cloud. The GPU's additive blending combines them,
creating the characteristic amber glow where particles overlap.
4. The Shimmer Effect: Animation System
The "shimmer" or "flicker" effect is what brings the particles to life. It's created through two
independent sine wave oscillations applied to each particle's brightness.
4.1 Dual-Wave Animation
Each particle has two animation components that modulate its brightness:
     Brightness Calculation (per particle, per frame): 1. PULSE Wave (slow, organic
     breathing): pulseValue = sin(particle.pulse) × 0.1 + 0.9 • Oscillates brightness
     between 0.8 and 1.0 (±10% variation) • Creates slow "breathing" effect • Phase
     advances: pulse += 0.04 per frame (at 120 FPS ≈ 0.76 Hz) 2. FLICKER Wave (fast,
     random shimmer): flickerValue = sin(particle.flicker) × 0.05 + 0.95 • Oscillates
     brightness between 0.9 and 1.0 (±5% variation) • Creates fast, subtle shimmer •
     Phase advances: flicker += flickerSpeed × 10 per frame • Default flickerSpeed = 0.15
     → ≈ 2.87 Hz 3. COMBINED Brightness: finalBrightness = pulseValue × flickerValue
     Range: 0.72 to 1.0
4.2 Why Two Waves?
The dual-wave system creates a more organic, natural appearance:
    <b>Aspect</b>           <b>Single Wave</b>                <b>Dual Wave</b>
    Visual Complexity       Uniform, mechanical oscillation   Complex, organic variation
    Temporal Depth          Predictable rhythm                Quasi-random patterns
    Nixie Tube Accuracy     Too perfect, digital-looking      Mimics gas discharge fluctuations
    Perceptual Appeal       Can appear monotonous             Holds visual interest
4.3 Phase Randomization
Critical to the effect: each particle starts with a random phase offset (0 to 2π). This ensures particles
shimmer independently rather than in lockstep.
     // During particle creation: particle.pulse = random(0, 2π) // Random starting phase
     particle.flicker = random(0, 2π) // Independent random phase // This means: // -
     Particle A might be at peak brightness // - Particle B might be at minimum
     brightness // - Particle C might be halfway // All at the same moment in time!
Without phase randomization, all particles would pulse in unison, creating a strobe-like effect. The
randomization makes the shimmer appear natural and organic.
4.4 Distance-Based Brightness
An additional factor modulates brightness based on how far a particle is from its original pixel center:
distanceFactor = 1.0 - min(particle.radius × 3, 1.0) This means: - Particles near
the center (radius ≈ 0): factor = 1.0 (full brightness) - Particles far from center
(radius > 0.33): factor = 0.0 (dim) Creates a natural falloff where outlier
particles are dimmer, focusing brightness toward character shapes.
5. Force Field Physics
Interactive force fields allow users to manipulate particles through mouse or touch input. Each drag or
click creates a temporary force field that pushes particles away.
5.1 Force Field Structure
     struct ForceField { QVector3D position; // Center of the force field float strength;
     // Force magnitude (typically 5.0) float radius; // Effective range (typically 50
     pixels) float life; // Remaining lifetime (0.0 to 1.0) float decay; // Life
     reduction per frame (0.05) QVector3D velocity; // Direction and speed };
5.2 Force Calculation
Each frame, every particle checks all active force fields and accumulates forces:
     For each particle: For each force field: // Calculate distance delta =
     particle.position - field.position distance = length(delta) // Only apply force
     within radius if distance < field.radius and distance > 0.1: // Inverse-square law
     (like gravity, but repulsive) forceMagnitude = (field.strength × field.life) /
     (distance² + 1) // Direction: away from field center forceDirection =
     normalize(delta) // Apply to velocity particle.velocity += forceDirection ×
     forceMagnitude × deltaTime // Update position from velocity particle.position +=
     particle.velocity × deltaTime // Apply damping (prevents endless motion)
     particle.velocity *= 0.95
5.3 Inverse-Square Force Law
The force calculation uses an inverse-square relationship, similar to electromagnetism:
     Force Strength vs Distance: At distance 1px: force = 5.0 / (1² + 1) = 2.5 At
     distance 2px: force = 5.0 / (4 + 1) = 1.0 At distance 5px: force = 5.0 / (25 + 1) ≈
     0.19 At distance 10px: force = 5.0 / (100 + 1) ≈ 0.05 The +1 in the denominator
     prevents division by zero and softens the force at very close distances.
5.4 Field Lifecycle
     1. CREATION (on mouse drag): - Position: Current mouse world coordinates - Strength:
     5.0 - Radius: 50 pixels - Life: 1.0 (100%) - Decay: 0.05 per frame 2. ACTIVE PHASE:
     - Each frame: life -= decay × deltaTime - Force strength scales with remaining life
     - At 120 FPS: field lasts ~1.67 seconds 3. REMOVAL: - When life <= 0, field is
     deleted - Affected particles retain their velocity (momentum)
This creates a natural "push" effect where particles scatter from mouse movement and gradually
return to their rest positions due to velocity damping.
6. GPU Rendering Pipeline
6.1 OpenGL Pipeline Overview
    CPU Side (C++): GPU Side (Shaders): ■■■■■■■■■■■■■■■■■ ■■■■■■■■■■■■■■■■■■■■
    1. Update particle physics → (Data ready in RAM) - Apply force fields - Update
    animations 2. Pack vertex data - Position (xyz): 3 floats - Color (rgba): 4 floats -
    Total: 7 floats per particle 3. Upload to GPU 4. Vertex Shader glBufferData() -
    Transform position → VRAM transfer - Set point size - Pass color to fragment 5.
    Rasterization - Generate fragments - gl_PointCoord per fragment 6. Fragment Shader -
    Calculate glow - Soft circle alpha - Output final color 7. Blending - Additive
    blending - Accumulate glow 8. Framebuffer → Display
6.2 Vertex Data Packing
Particles are packed into a flat array for GPU upload. Each particle is 7 consecutive floats:
    Per-Particle Data (28 bytes): [px, py, pz, r, g, b, a] Example for 10,000 particles:
    - Array size: 70,000 floats - Memory: 280 KB - Upload time: < 1ms on modern GPUs
    Vertex attribute layout: - Location 0: position (3 floats, offset 0) - Location 1:
    color (4 floats, offset 12 bytes)
6.3 Additive Blending
The key to the glow effect is additive blending. When multiple semi-transparent particles overlap, their
colors add together, creating bright hotspots:
    OpenGL Blend Function: glBlendFunc(GL_SRC_ALPHA, GL_ONE) Color Accumulation:
    finalColor = sourceColor × sourceAlpha + destinationColor × 1.0 Effect on
    overlapping particles: - 1 particle at (r,g,b,a): contributes r×a to red channel - 2
    particles overlapping: r■×a■ + r■×a■ - 10 particles: Σ(r■×a■) → very bright! This
    creates: - Bright character cores (many overlapping particles) - Dimmer edges (fewer
    particles) - Glowing halos (particle spread)
7. Shader Implementation
7.1 Vertex Shader
   #version 450 core layout (location = 0) in vec3 position; layout (location = 1) in
   vec4 color; out vec4 fragColor; uniform mat4 projection; uniform float pointSize;
   void main() { // Transform position to clip space gl_Position = projection *
   vec4(position, 1.0); // Set rendered point size (in pixels) gl_PointSize =
   pointSize; // Pass color to fragment shader fragColor = color; }
The vertex shader is simple: it transforms particle positions and sets their render size.
7.2 Fragment Shader (The Glow)
   #version 450 core in vec4 fragColor; out vec4 FragColor; uniform float
   glowIntensity; void main() { // gl_PointCoord: (0,0) to (1,1) across the point vec2
   coord = gl_PointCoord - vec2(0.5); // Center at (0,0) float dist = length(coord); //
   Distance from center // Soft circle with smooth edges // smoothstep creates gradient
   from 0.3 to 0.5 radius float alpha = 1.0 - smoothstep(0.3, 0.5, dist); //
   Exponential glow (brightest at center, fades outward) float glow = exp(-dist * 4.0)
   * glowIntensity; // Add glow to base color (allows HDR values > 1.0) vec3 finalColor
   = fragColor.rgb * (1.0 + glow); // Output with alpha for blending FragColor =
   vec4(finalColor, alpha * fragColor.a); }
7.3 Glow Mathematics
   The glow function: e^(-dist × 4) At center (dist = 0.0): glow = e^0 = 1.0 → 100%
   additional brightness At distance 0.25: glow = e^(-1) ≈ 0.37 → 37% additional
   brightness At distance 0.5: glow = e^(-2) ≈ 0.14 → 14% additional brightness At
   distance 1.0: glow = e^(-4) ≈ 0.018 → ~2% additional brightness This creates a
   natural falloff that mimics light diffusion. The factor 4 controls falloff speed
   (higher = tighter glow).
7.4 Color Temperature Modes
The system supports three color modes by modulating RGB channels:
   Mode 0 - AMBER (default): color.rgb = color.rgb (unmodified) Produces warm
   orange-amber tones Mode 1 - ORANGE: color.r = color.r × 1.0 color.g = color.g × 0.8
   color.b = color.b × 0.4 Shifts toward pure orange Mode 2 - WHITE: value =
   max(color.r, color.g, color.b) color.rgb = vec3(value, value, value) Creates
   monochrome white glow
8. Performance Optimization
8.1 Particle Count Scaling
  <b>Density</b><b>Particles/Char</b><b>80×25 Screen</b> <b>GPU Load</b>               <b>FPS (RTX 4090)</b>
           5             ~10               ~20,000                 Very Low                  120+ FPS
          10             ~20               ~40,000                   Low                     120+ FPS
     20 (default)        ~40               ~80,000                  Medium                    120 FPS
          30             ~60              ~120,000              Medium-High                   120 FPS
          50            ~100              ~200,000                   High                   90-120 FPS
8.2 Optimization Techniques
   <b>Technique</b>        <b>Impact</b> <b>Description</b>
   GPU Upload Once         High           Only upload changed particles, not entire buffer
   Particle Pooling        Medium         Reuse particle objects instead of allocating
   Force Field Culling     Low            Remove expired fields from update loop
   Z-Buffer Disable        Low            Particles don't need depth testing
   Batch Rendering         High           Single draw call for all particles per layer
   VBO Streaming           Medium         GL_STREAM_DRAW for frequently updated data
8.3 Memory Footprint
   Memory Usage Calculation: Per Particle: - Position (vec3): 12 bytes - Color (vec4):
   16 bytes - Pulse (float): 4 bytes - Flicker (float): 4 bytes - Radius (float): 4
   bytes - Velocity (vec3): 12 bytes ■■■■■■■■■■■■■■■■■■■■■■■■■■■■ Total: 52
   bytes per particle For 80,000 particles (density=20, full screen): - CPU Memory: 52
   × 80,000 = 4.16 MB - GPU Memory: 28 × 80,000 = 2.24 MB (vertex data only) - Total:
   ~6.4 MB This is negligible on modern systems with 8+ GB RAM.
8.4 Frame Time Budget (120 FPS Target)
   120 FPS = 8.33ms per frame Typical frame breakdown: - Particle physics update: 0.5ms
   - Vertex data packing: 0.3ms - GPU upload: 0.2ms - Vertex shader: 0.8ms -
   Rasterization: 1.5ms - Fragment shader: 2.5ms - Blending: 1.0ms - Post-processing:
   0.5ms - Swap buffers: 0.5ms ■■■■■■■■■■■■■■■■■■■■■■■■■■■ Total: 7.8ms (leaves
   0.5ms margin) On high-end GPUs (RTX 4090), shader time is ~1ms, allowing margin for
200+ FPS in practice.Summary
The Amber SSH particle system achieves its distinctive aesthetic through a carefully orchestrated
combination of techniques:
    1. DECOMPOSITION: Terminal characters → 5×7 bitmaps → dense particle clouds 2.
    DISTRIBUTION: Gaussian randomness creates natural, organic clustering 3. ANIMATION:
    Dual sine waves (pulse + flicker) with random phase offsets produce complex, living
    shimmer effects 4. PHYSICS: Inverse-square force fields enable real-time interaction
    while velocity damping ensures particles return to rest 5. RENDERING: Multi-layer
    particle clouds with additive blending create deep, glowing effects reminiscent of
    nixie tubes 6. SHADERS: Exponential glow functions and soft alpha falloff produce
    authentic CRT-like luminescence 7. PERFORMANCE: GPU-accelerated rendering handles
    100,000+ particles at 120 FPS on modern hardware
The result is a terminal that feels alive—characters don't simply appear on screen, they materialize as
swirling clouds of light, pulsing and shimmering like vintage phosphor displays, while responding
organically to user touch.
This documentation has covered the complete technical implementation. For questions or
customizations, refer to the source code in ParticleRenderer.cpp and the shader files.
